
from pprint import pprint

'''Иногда нам нужны простые одноразовые функции, для которых def  это слишком жирно
для этого есть lambda'''
########## пример 1  lambda - функуия ################################

# my_function = lambda x: x + 30
# print(my_function(5))
# print(type(my_function))
# print(my_function.__name__)
'''У нее нет имени функциии она всегда будет lambda  по этому ссылать на нее не получиться и вызывать тоже'''

print("############################################################################")

# my_numbers = [1, 2, 3, 4, 5]
#
# result = map(lambda x: x * 2, my_numbers)
# print(result)
# print(list(result))

print("############################################################################")

##########################################################################################
'''Пример номер 2 -lambda форма может принимать как несколько параметров так и е одного'''
########## пример - 2  lambda - функуия ###################################################

# my_numbers = [1, 2, 3, 4, 5]
# they_numbers = [3,5,7,9,0,6,4,2,2,5,8,0]
#
# result = map(lambda y, x: y - x,  they_numbers,my_numbers)
# print(result)
# print(list(result))

'''lambda - форма функции имеет ограниченное применение: 
 - Она создается в процессе выполнения кода (а не при компеляции ) и может просадить бысродействие 
 - Она плохо сориализуется -  могут быть проблемы в крупных файроврках
 - Не пытайтесь записать лямбду в сложное вырожение: если там более 3-5 операторов -сделать нормальную функую def '''

print("############################################################################")

###############################################################################################
'''Создаем большие функции прям на лету'''
########## пример - 3  Функуии на лету #######################################################
# def get_multiplier_v1(n):
#     if n == 2:
#         def multiplier(x):
#             return x * 2
#
#     elif n == 3:
#         def multiplier(x):
#             return x * 3
#     else:
#         raise Exception("Я могу сделать умножение только на 2 или 3!")
#
#     return multiplier
#
# my_numbers = [3,5,7,9,0,6,4,2,2,5,8,0]
#
# by_1 =  get_multiplier_v1(2)
# by_2 = get_multiplier_v1(3)
#
# result = map(by_1, my_numbers)
# print(list(result))
# result = map(by_2, my_numbers)
# print(list(result))
print("############################################################################")
########## пример - 4  Функуии на лету #######################################################

def get_multiplier_v2(n):
    def multiplier(x):
            return x * n

    return multiplier

by_3 =  get_multiplier_v2(2)
print(by_3(x=45))
# my_numbers = [3,5,7,9,0,6,4,2,2,5,8,0]

'''by_10 =  get_multiplier_v2(20)
by_20 = get_multiplier_v2(300)
'''

'''print(list(map(by_10, my_numbers)))
print(list(map(by_20, my_numbers)))'''

'''это называется замыкание в переменной Python - это функциональный объект который запоминает занчение 
 во внешней областях, даже если они отсутствуют в памяти.'''
print("############################################################################")

########## пример - 5  Функуии на лету делаем матрицу #######################################################
'''Пример -5 показывает то что не стоит передовать в аргументы функций изменяемые объекты и замыкать их '''
def matrix(some_list):
     def multiply_columm(x):
         res = []
         for element in some_list:
             res.append(element * x)
         return res

     return multiply_columm

my_numbers = [1,2, 3, 4, 5,6,7,8,9,1]
they_numbers = [3,5,7,9,0,6,4,2,2,5,8,0]
matrix_on = matrix(my_numbers)
result = map(matrix_on, they_numbers)
pprint(list(result))


# my_numbers_2 = [10,20,40]
# result = map(matrix_on,they_numbers)
# pprint(list(result))

'''Дело в том что если мы добавим изменяемые объекты в функцию т запустим программу то ошибка не вызовется а матрица
 наполница еще больше пример вот тут выше закоментированный'''
print("############################################################################")
#####################################################################################################################
'''Пример 6 - создает объект, который можно вызывать'''
class Multiplier:
    def __init__(self, n):
        self.n = n


    def __call__(self, x):
        #если есть такой метод у класса - то его объект можно "вызывать" как функцию
        return x * self.n


my_numbers = [3,5,7,9,0,6,4,2,2,5,8,0]
by_1 = Multiplier(n = 100500)
result = by_1(x=85697)
print(result)

result = map(by_1, my_numbers)
print(list(result))
